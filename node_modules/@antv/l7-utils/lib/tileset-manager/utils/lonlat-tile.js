"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTileIndices = getTileIndices;
exports.getTileWarpXY = void 0;
exports.osmLonLat2TileXY = osmLonLat2TileXY;
exports.osmTileXY2LonLat = osmTileXY2LonLat;
exports.tileToBounds = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _const = require("../const");

function osmLonLat2TileXY(lon, lat, zoom) {
  var x = Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
  var y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
  return [x, y];
}

function osmTileXY2LonLat(x, y, zoom) {
  var lon = x / Math.pow(2, zoom) * 360 - 180;
  var n = Math.PI - 2 * Math.PI * y / Math.pow(2, zoom);
  var lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  return [lon, lat];
}

var tileToBounds = function tileToBounds(x, y, z) {
  var _osmTileXY2LonLat = osmTileXY2LonLat(x, y, z),
      _osmTileXY2LonLat2 = (0, _slicedToArray2.default)(_osmTileXY2LonLat, 2),
      minLng = _osmTileXY2LonLat2[0],
      maxLat = _osmTileXY2LonLat2[1];

  var _osmTileXY2LonLat3 = osmTileXY2LonLat(x + 1, y + 1, z),
      _osmTileXY2LonLat4 = (0, _slicedToArray2.default)(_osmTileXY2LonLat3, 2),
      maxLng = _osmTileXY2LonLat4[0],
      minLat = _osmTileXY2LonLat4[1];

  return [minLng, minLat, maxLng, maxLat];
};

exports.tileToBounds = tileToBounds;

function getTileIndices(_ref) {
  var zoom = _ref.zoom,
      latLonBounds = _ref.latLonBounds,
      _ref$maxZoom = _ref.maxZoom,
      maxZoom = _ref$maxZoom === void 0 ? Infinity : _ref$maxZoom,
      _ref$minZoom = _ref.minZoom,
      minZoom = _ref$minZoom === void 0 ? 0 : _ref$minZoom,
      _ref$zoomOffset = _ref.zoomOffset,
      zoomOffset = _ref$zoomOffset === void 0 ? 0 : _ref$zoomOffset,
      _ref$extent = _ref.extent,
      extent = _ref$extent === void 0 ? _const.DEFAULT_EXTENT : _ref$extent;
  var z = Math.ceil(zoom) + zoomOffset;

  if (z < minZoom) {
    z = minZoom;
  } else if (z > maxZoom) {
    z = maxZoom;
  }

  var _latLonBounds = (0, _slicedToArray2.default)(latLonBounds, 4),
      minLng = _latLonBounds[0],
      minLat = _latLonBounds[1],
      maxLng = _latLonBounds[2],
      maxLat = _latLonBounds[3];

  var bounds = [Math.max(minLng, extent[0]), Math.max(minLat, extent[1]), Math.min(maxLng, extent[2]), Math.min(maxLat, extent[3])];
  var indices = [];

  var _osmLonLat2TileXY = osmLonLat2TileXY(bounds[0], bounds[1], z),
      _osmLonLat2TileXY2 = (0, _slicedToArray2.default)(_osmLonLat2TileXY, 2),
      minX = _osmLonLat2TileXY2[0],
      maxY = _osmLonLat2TileXY2[1];

  var _osmLonLat2TileXY3 = osmLonLat2TileXY(bounds[2], bounds[3], z),
      _osmLonLat2TileXY4 = (0, _slicedToArray2.default)(_osmLonLat2TileXY3, 2),
      maxX = _osmLonLat2TileXY4[0],
      minY = _osmLonLat2TileXY4[1];

  for (var x = minX; x <= maxX; x++) {
    for (var y = minY; y <= maxY; y++) {
      indices.push({
        x: x,
        y: y,
        z: z
      });
    }
  }

  return indices;
}

var getTileWarpXY = function getTileWarpXY(x, y, z) {
  var scale = Math.pow(2, z);
  var maxIndex = scale - 1;
  var distance = scale;
  var warpX = x;
  var warpY = y;

  if (warpX < 0) {
    warpX = warpX + distance;
  } else if (warpX > maxIndex) {
    warpX = warpX % distance;
  }

  return {
    warpX: warpX,
    warpY: warpY
  };
};

exports.getTileWarpXY = getTileWarpXY;
//# sourceMappingURL=lonlat-tile.js.map